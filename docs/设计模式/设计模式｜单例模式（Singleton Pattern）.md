---
title: 设计模式(8)｜单例模式（Singleton Pattern）
date: 2024-04-09
---
单例模式（Singleton Pattern）是一种创建型设计模式，它确保类只有一个实例，并提供一个全局访问点来访问这个实例。
# 适用场景
单例模式在许多场景中都可以发挥作用，特别是需要确保只有一个实例存在并提供全局访问点的情况。单例模式适用于需要严格控制一个类只能有一个实例存在的情况，例如线程池、缓存、日志等。
以下是一些常见的使用场景：

1.  **资源管理器**：例如文件系统的资源管理器，数据库连接池等，这些资源在整个应用程序中只需要一个实例来管理。
2.  **日志记录器**：在应用程序中需要记录日志的情况下，可以使用单例模式确保所有的日志消息都被记录到同一个日志文件中。
3.  **配置管理器**：当应用程序需要读取配置文件中的配置信息时，可以使用单例模式确保在整个应用程序中只有一个配置管理器实例来管理配置信息。
4.  **线程池**：在多线程环境中，可以使用单例模式来创建线程池实例，确保所有的线程都从同一个线程池中获取任务并执行。
5.  **缓存**：在应用程序中需要缓存数据时，可以使用单例模式确保所有的数据都被缓存在同一个缓存实例中。
6.  **计数器**：例如在应用程序中需要记录某个操作被执行的次数时，可以使用单例模式来创建计数器实例，确保所有的操作都被记录到同一个计数器实例中。
7.  **GUI组件**：在图形用户界面（GUI）应用程序中，有些组件可能需要全局访问，例如主窗口、对话框等，可以使用单例模式确保这些组件只有一个实例存在。
8.  **代理对象**：在需要对外提供统一的访问接口时，可以使用单例模式创建代理对象，确保所有的请求都被转发到同一个代理对象中进行处理。

总之，单例模式适用于需要确保只有一个实例存在并提供全局访问点的情况下，可以帮助简化代码实现、降低资源消耗、提高系统性能。
# 优缺点
单例模式是一种常见的设计模式，它具有以下优点和缺点：
## 优点
1.  **全局唯一实例**：单例模式确保在整个应用程序中只有一个实例存在，可以提供一个全局的访问点，方便对实例的管理和调用。
2.  **节省资源**：由于只有一个实例存在，可以避免重复创建实例，节省了系统资源。
3.  **避免竞态条件**：在多线程环境下，使用单例模式可以避免由于竞态条件而导致的问题，如资源争夺、数据不一致等。
4.  **实现了懒加载**：某些单例模式的实现方式（如懒汉式）在需要时才创建实例，实现了延迟加载，节省了内存空间。
## 缺点

1.  **可能引入全局状态**：由于单例模式提供了全局访问点，可能会导致多个部分之间共享了同一个状态，增加了系统的耦合性。
2.  **可能造成性能瓶颈**：在高并发环境下，单例模式的实现需要考虑线程安全性，可能会引入锁机制，导致性能下降。
3.  **隐藏了依赖关系**：单例模式的使用会隐藏类的依赖关系，增加了代码的复杂性和理解难度。
4.  **不利于扩展和测试**：单例模式一般是通过静态方法获取实例，难以进行扩展和替换，也不利于单元测试。
5.  **可能造成内存泄漏**：如果实例被长时间持有而不释放，可能会造成内存泄漏，特别是在移动端或长时间运行的服务中。

综上所述，单例模式在某些情况下可以提供一种方便的对象管理方式，但也需要注意其可能引入的问题和局限性，需要根据具体情况进行权衡和选择。
# 示例
在 Java 中，可以通过以下几种方式实现单例模式：

1.  **懒汉式（Lazy Initialization）**：在第一次使用时创建实例。
```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```


2.  **饿汉式（Eager Initialization）**：在类加载时就创建实例。
```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```


3.  **双重检查锁定（Double-Checked Locking）**：在第一次使用时创建实例，使用双重检查锁定确保线程安全。
```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```


4.  **静态内部类（Static Inner Class）**：利用类加载机制保证线程安全，使用静态内部类持有实例。
```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

以上是一些常见的单例模式实现方式，可以根据实际需求选择适合的方式。需要注意的是，在多线程环境下确保线程安全是实现单例模式时需要考虑的重要问题。
# 分布式部署情况下，保证单例

- 在分布式部署的情况下，传统的单例模式无法保证在整个分布式系统中只有一个实例存在，因为不同的部署实例可能运行在不同的服务器上，它们之间无法直接共享内存或状态。
- 在分布式环境中，可以使用分布式锁来保证全局唯一性。例如，可以使用基于分布式存储的锁机制，如ZooKeeper或Redis等，来确保在整个分布式系统中只有一个实例可以获取到锁，从而实现单例模式的效果。
- 另一种方法是使用分布式缓存，例如使用Redis存储单例实例的状态，并在所有部署实例之间共享该状态。但这种方法需要注意处理分布式系统中的并发和一致性问题。
- 总之，在分布式环境中要实现单例模式需要考虑分布式系统的特性，并选择适合的分布式锁或共享状态的机制来确保全局唯一性。
# 常见面试题
在面试中，面试官可能会针对单例模式提出各种问题，包括但不限于以下几个方面：

1.  **单例模式的基本实现**：
- 问题：你能简要描述一下单例模式的基本实现吗？
- 答案：单例模式确保一个类只有一个实例，并提供一个全局访问点。基本实现包括私有化构造函数、私有静态成员变量以及提供公共静态方法来获取实例。
2.  **多线程环境下的单例模式**：
- 问题：在多线程环境下，如何确保单例模式的线程安全性？
- 答案：可以使用懒汉式双重检查锁定（Double-Checked Locking）或者静态内部类的方式来确保线程安全。
3.  **单例模式的延迟初始化**：
- 问题：懒汉式和饿汉式单例模式的区别是什么？它们各自的优缺点是什么？
- 答案：懒汉式单例模式在第一次使用时才创建实例，而饿汉式单例模式在类加载时就创建实例。懒汉式的优点是节省了内存，但缺点是在多线程环境下需要考虑线程安全性；饿汉式的优点是简单直接，但缺点是可能会造成资源浪费。
4.  **反射和序列化对单例模式的影响**：
- 问题：使用反射和序列化时，单例模式会遇到什么问题？如何解决这些问题？
- 答案：反射可以通过在私有构造函数中添加判断来防止多次实例化；序列化可以通过实现 `readResolve()` 方法来防止反序列化时创建新实例。
5.  **单例模式的破坏**：
- 问题：有没有办法破坏单例模式？如何防止单例模式被破坏？
- 答案：通过反射和序列化等手段可以破坏单例模式。为了防止破坏，可以在私有构造函数中添加逻辑判断，或者使用枚举方式实现单例模式，枚举类型的序列化和反射都是安全的。

以上问题涵盖了单例模式的基本概念、实现方式、线程安全性、延迟初始化、防止破坏等方面，可以帮助全面了解单例模式及其应用。
