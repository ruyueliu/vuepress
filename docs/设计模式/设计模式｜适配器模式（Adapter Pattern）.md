---
title: 设计模式(11)｜适配器模式（Adapter Pattern）
date: 2024-04-12
---
@[toc]
适配器模式（Adapter Pattern）是一种结构型设计模式，用于将一个类的接口转换成客户端所期望的另一个接口。这种模式通常用于解决两个已有接口之间不兼容的情况。适配器模式使得不兼容的接口能够协同工作，而无需修改已有的代码。这对于集成已有代码库或者第三方组件时非常有用，因为它可以帮助在不破坏现有接口的情况下实现必要的功能补充。
# 结构
在适配器模式中，有三个主要角色：

1.  目标接口（Target Interface）：客户端所期望的接口，适配器将会实现这个接口。
2.  适配器（Adapter）：适配器是一个类，它实现了目标接口，并且包装了一个或多个被适配的类的对象。适配器通过调用被适配类的方法来实现目标接口。
3.  被适配者（Adaptee）：被适配的类，它拥有客户端所需的功能，但是其接口与客户端期望的接口不兼容。
# 优点

1. **解耦性增强：** 适配器模式可以将客户端代码与具体的被适配者类解耦，使得它们之间的关系更加灵活，降低了耦合度。
2. **复用性提高：** 适配器模式可以重用现有的类，而不需要修改其代码，只需编写一个适配器类即可。
3. **灵活性增强：** 可以在不修改现有代码的情况下引入新的功能，只需要编写适配器类来适配新的功能即可。
4. **增加了系统的扩展性：** 当需要添加新的被适配者类时，可以很容易地编写新的适配器来适配这些类，而不会影响现有的代码。
# 缺点

1. **增加了代码复杂性：** 引入适配器会增加代码的复杂性，特别是在系统中存在大量的适配器时，会增加代码的维护成本。
2. **过多使用可能会导致系统变得混乱：** 过度使用适配器模式可能会导致系统中存在大量的适配器类，使得系统变得混乱难以理解。
3. **性能损耗：** 在适配器模式中，由于需要进行额外的适配处理，可能会引入一定的性能损耗，尤其是在处理大量数据时。

综上所述，适配器模式在某些情况下能够提供方便和灵活性，但在设计时需要权衡其优缺点，避免过度使用导致系统复杂性增加。

# 示例
假设有一个 `Rectangle` 类，我们希望能够使用它来计算面积，但是它的方法名是 `calculatePerimeter()` 而不是我们期望的 `calculateArea()`。我们可以使用适配器模式来解决这个问题。
首先，让我们创建目标接口 `Shape`：
```java
// 目标接口
interface Shape {
    double calculateArea();
}
```
然后，我们创建被适配者类 `Rectangle`：
```java
// 被适配者类
class Rectangle {
    double length;
    double width;

    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    double calculatePerimeter() {
        return 2 * (length + width);
    }
}
```
接下来，我们创建适配器类 `RectangleAdapter`，它实现了 `Shape` 接口，并且包装了 `Rectangle` 类的对象：
```java
// 适配器类
class RectangleAdapter implements Shape {
    Rectangle rectangle;

    RectangleAdapter(Rectangle rectangle) {
        this.rectangle = rectangle;
    }

    @Override
    public double calculateArea() {
        return rectangle.length * rectangle.width;
    }
}
```
最后，我们创建一个测试类 `AdapterPatternDemo`：
```java
public class AdapterPatternDemo {
    public static void main(String[] args) {
        // 创建一个Rectangle对象
        Rectangle rectangle = new Rectangle(5, 3);
        
        // 创建一个RectangleAdapter对象，将Rectangle对象适配成Shape接口
        Shape shape = new RectangleAdapter(rectangle);

        // 调用Shape接口的calculateArea方法，实际上调用的是RectangleAdapter的calculateArea方法
        double area = shape.calculateArea();
        System.out.println("Area of the rectangle: " + area);
    }
}
```
以上就是一个简单的使用适配器模式的示例。通过适配器模式，我们可以将现有的 `Rectangle` 类适配成 `Shape` 接口，从而实现了面积的计算。
# 装饰器和适配器有什么区别
装饰器模式和适配器模式在设计目的、结构和使用场景上有明显的区别：

1.  **设计目的：**
- 装饰器模式的设计目的是动态地给对象添加额外的职责，而不改变其接口。它允许你通过嵌套对象来添加功能，而不是修改类本身。
- 适配器模式的设计目的是将一个类的接口转换成另一个接口，以满足客户端的期望。它主要用于解决两个已有接口不兼容的情况。
2.  **结构：**
- 装饰器模式通常由一个抽象组件、具体组件、抽象装饰器和具体装饰器组成。抽象组件定义了装饰器和具体组件的共同接口，具体组件是被装饰的对象，抽象装饰器和具体装饰器都实现了抽象组件，并且持有一个指向具体组件的引用。
- 适配器模式通常由目标接口、适配器和被适配者组成。目标接口是客户端期望的接口，适配器实现了目标接口并且持有一个被适配者的引用，被适配者是需要被适配的类。
3.  **使用场景：**
- 装饰器模式适用于以下情况：
    - 需要动态地给对象添加额外的职责，而不改变其接口。
    - 需要在运行时透明地扩展对象的功能，以避免类爆炸问题。
- 适配器模式适用于以下情况：
    - 需要将一个类的接口转换成另一个接口，以满足客户端的期望。
    - 需要集成一个已有的类到另一个接口不兼容的系统中。

综上所述，装饰器模式和适配器模式在设计目的、结构和使用场景上有明显的区别，理解它们之间的差异有助于正确地选择和应用设计模式。
# 常见面试题
在面试中，可能会遇到一些与适配器相关的问题，以下是一些常见的问题以及可能的答案：

1.  **请解释适配器模式是什么，它解决了什么问题？**
    答：适配器模式是一种结构型设计模式，用于将一个类的接口转换成另一个接口，以满足客户端的期望。它主要解决了两个已有接口之间不兼容的问题，使得它们能够协同工作而无需修改已有代码。
2.  **能否举例说明适配器模式的使用场景？**
    答：一个常见的使用场景是在集成第三方库或组件时，新的组件提供的接口与现有系统的接口不兼容。通过编写适配器来将新组件的接口转换成现有系统所期望的接口，实现两者的无缝集成。
3.  **适配器模式与装饰器模式有何区别？**
    答：适配器模式用于将一个类的接口转换成另一个接口，以满足客户端的期望；而装饰器模式用于在不改变接口的情况下给对象添加新的行为。换句话说，适配器模式主要解决接口不兼容的问题，而装饰器模式主要用于动态地添加功能。
4.  **在实际项目中，你是如何使用适配器模式的？**
    答：举例来说，假设我在一个项目中需要使用第三方支付接口，但是该接口与我们内部系统的支付接口不兼容。我会创建一个支付适配器类，将第三方支付接口的方法转换成我们内部系统所期望的接口，从而无缝集成第三方支付服务。
5.  **适配器模式有哪些优缺点？**
    答：适配器模式的优点包括解耦性增强、复用性提高、灵活性增强以及增加了系统的扩展性。然而，它也会增加代码复杂性，可能导致系统变得混乱，以及引入一定的性能损耗。

以上是一些常见的适配器模式相关的面试问题，了解这些问题以及如何回答可以帮助你在面试中展现出对适配器模式的理解和运用能力。

